package ipsec

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"strings"
)

// IKEv2Config represents IKEv2/IPsec configuration
type IKEv2Config struct {
	// Server configuration
	ServerAddress string
	ServerID      string
	ServerCert    string

	// Client configuration
	ClientID       string
	ClientCert     string
	ClientKey      string
	PreSharedKey   string

	// IKE parameters
	IKEVersion     string // IKEv2
	AuthMethod     string // PSK, RSA, EAP
	EncryptionAlg  string // AES-256-GCM, ChaCha20-Poly1305
	IntegrityAlg   string // SHA256, SHA384, SHA512
	DHGroup        string // modp2048, modp4096, ecp256, ecp384

	// IPsec parameters
	ESPEncryption  string
	ESPIntegrity   string
	PFSGroup       string
	Lifetime       int // seconds
	RekeyTime      int // seconds

	// Network settings
	LocalSubnet    string
	RemoteSubnet   string
	DNS            []string
	SplitTunneling bool
	Routes         []Route

	// Advanced features
	Mobike         bool // Mobility and Multihoming Protocol
	NAT_Traversal  bool
	DeadPeerDetection DPDConfig
}

// Route represents a network route
type Route struct {
	Destination string
	Gateway     string
	Metric      int
}

// DPDConfig configures Dead Peer Detection
type DPDConfig struct {
	Enabled  bool
	Interval int // seconds
	Timeout  int // seconds
	Action   string // restart, clear, hold
}

// GenerateStrongSWanConfig generates strongSwan configuration
func GenerateStrongSWanConfig(cfg IKEv2Config) (string, error) {
	var sb strings.Builder

	// IPsec configuration
	sb.WriteString("# strongSwan IKEv2 Configuration\n")
	sb.WriteString("# Generated by Aureo VPN\n\n")

	// Connection definition
	sb.WriteString("conn aureo-vpn\n")
	sb.WriteString("    auto=start\n")
	sb.WriteString(fmt.Sprintf("    right=%s\n", cfg.ServerAddress))
	sb.WriteString(fmt.Sprintf("    rightid=%s\n", cfg.ServerID))
	sb.WriteString("    rightsubnet=0.0.0.0/0\n")
	sb.WriteString("    rightauth=pubkey\n")

	sb.WriteString(fmt.Sprintf("    left=%s\n", "%defaultroute"))
	sb.WriteString(fmt.Sprintf("    leftid=%s\n", cfg.ClientID))
	sb.WriteString("    leftauth=pubkey\n")
	sb.WriteString(fmt.Sprintf("    leftcert=%s\n", cfg.ClientCert))

	// IKE parameters
	sb.WriteString(fmt.Sprintf("    ike=%s-%s-%s!\n",
		cfg.EncryptionAlg,
		cfg.IntegrityAlg,
		cfg.DHGroup))

	// ESP parameters
	sb.WriteString(fmt.Sprintf("    esp=%s-%s-%s!\n",
		cfg.ESPEncryption,
		cfg.ESPIntegrity,
		cfg.PFSGroup))

	// Timers
	sb.WriteString(fmt.Sprintf("    lifetime=%ds\n", cfg.Lifetime))
	sb.WriteString(fmt.Sprintf("    margintime=%ds\n", cfg.RekeyTime))

	// Advanced features
	if cfg.Mobike {
		sb.WriteString("    mobike=yes\n")
	}

	if cfg.DeadPeerDetection.Enabled {
		sb.WriteString(fmt.Sprintf("    dpdaction=%s\n", cfg.DeadPeerDetection.Action))
		sb.WriteString(fmt.Sprintf("    dpddelay=%ds\n", cfg.DeadPeerDetection.Interval))
		sb.WriteString(fmt.Sprintf("    dpdtimeout=%ds\n", cfg.DeadPeerDetection.Timeout))
	}

	// Key exchange
	sb.WriteString("    keyexchange=ikev2\n")
	sb.WriteString("    type=tunnel\n")
	sb.WriteString("    compress=no\n")

	return sb.String(), nil
}

// GenerateIPsecSecrets generates ipsec.secrets file
func GenerateIPsecSecrets(cfg IKEv2Config) string {
	var sb strings.Builder

	sb.WriteString("# IPsec secrets file\n")
	sb.WriteString("# Generated by Aureo VPN\n\n")

	if cfg.PreSharedKey != "" {
		sb.WriteString(fmt.Sprintf(": PSK \"%s\"\n", cfg.PreSharedKey))
	}

	if cfg.ClientKey != "" {
		sb.WriteString(fmt.Sprintf(": RSA %s\n", cfg.ClientKey))
	}

	return sb.String()
}

// GeneratePSK generates a secure Pre-Shared Key
func GeneratePSK() (string, error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		return "", fmt.Errorf("failed to generate PSK: %w", err)
	}
	return hex.EncodeToString(bytes), nil
}

// ValidateConfig validates IKEv2 configuration
func ValidateConfig(cfg IKEv2Config) error {
	if cfg.ServerAddress == "" {
		return fmt.Errorf("server address is required")
	}

	if cfg.EncryptionAlg == "" {
		return fmt.Errorf("encryption algorithm is required")
	}

	if cfg.AuthMethod == "PSK" && cfg.PreSharedKey == "" {
		return fmt.Errorf("pre-shared key is required for PSK authentication")
	}

	if cfg.AuthMethod == "RSA" && (cfg.ClientCert == "" || cfg.ClientKey == "") {
		return fmt.Errorf("client certificate and key are required for RSA authentication")
	}

	return nil
}

// DefaultIKEv2Config returns a secure default configuration
func DefaultIKEv2Config(serverAddr string) IKEv2Config {
	return IKEv2Config{
		ServerAddress:  serverAddr,
		IKEVersion:     "IKEv2",
		AuthMethod:     "RSA",
		EncryptionAlg:  "aes256gcm16",
		IntegrityAlg:   "sha256",
		DHGroup:        "modp2048",
		ESPEncryption:  "aes256gcm16",
		ESPIntegrity:   "sha256",
		PFSGroup:       "modp2048",
		Lifetime:       3600,
		RekeyTime:      3000,
		Mobike:         true,
		NAT_Traversal:  true,
		DeadPeerDetection: DPDConfig{
			Enabled:  true,
			Interval: 30,
			Timeout:  120,
			Action:   "restart",
		},
	}
}
