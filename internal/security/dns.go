package security

import (
	"fmt"
	"log"
	"os"
	"os/exec"
)

// DNSManager handles DNS leak protection
type DNSManager struct {
	originalResolv string
	vpnDNS         []string
	backupPath     string
}

// NewDNSManager creates a new DNS manager
func NewDNSManager(vpnDNS []string) *DNSManager {
	return &DNSManager{
		vpnDNS:     vpnDNS,
		backupPath: "/etc/resolv.conf.vpn-backup",
	}
}

// EnableDNSProtection configures system to use VPN DNS servers
func (d *DNSManager) EnableDNSProtection() error {
	log.Println("Enabling DNS leak protection...")

	// Backup original resolv.conf
	if err := d.backupResolvConf(); err != nil {
		return fmt.Errorf("failed to backup resolv.conf: %w", err)
	}

	// Write new resolv.conf with VPN DNS servers
	if err := d.writeVPNResolv(); err != nil {
		return fmt.Errorf("failed to write VPN DNS config: %w", err)
	}

	// Block non-VPN DNS queries
	if err := d.blockNonVPNDNS(); err != nil {
		log.Printf("Warning: failed to block non-VPN DNS: %v", err)
	}

	log.Println("DNS leak protection enabled")
	return nil
}

// DisableDNSProtection restores original DNS configuration
func (d *DNSManager) DisableDNSProtection() error {
	log.Println("Disabling DNS leak protection...")

	// Restore original resolv.conf
	if err := d.restoreResolvConf(); err != nil {
		return fmt.Errorf("failed to restore resolv.conf: %w", err)
	}

	// Remove DNS blocking rules
	if err := d.unblockDNS(); err != nil {
		log.Printf("Warning: failed to unblock DNS: %v", err)
	}

	log.Println("DNS leak protection disabled")
	return nil
}

// backupResolvConf creates a backup of /etc/resolv.conf
func (d *DNSManager) backupResolvConf() error {
	content, err := os.ReadFile("/etc/resolv.conf")
	if err != nil {
		return err
	}

	d.originalResolv = string(content)
	return os.WriteFile(d.backupPath, content, 0644)
}

// restoreResolvConf restores the original /etc/resolv.conf
func (d *DNSManager) restoreResolvConf() error {
	if d.originalResolv == "" {
		// Try to read from backup
		content, err := os.ReadFile(d.backupPath)
		if err != nil {
			return err
		}
		d.originalResolv = string(content)
	}

	if err := os.WriteFile("/etc/resolv.conf", []byte(d.originalResolv), 0644); err != nil {
		return err
	}

	// Remove backup file
	os.Remove(d.backupPath)
	return nil
}

// writeVPNResolv writes VPN DNS servers to resolv.conf
func (d *DNSManager) writeVPNResolv() error {
	content := "# VPN DNS Configuration\n"
	content += "# Generated by Aureo VPN\n\n"

	for _, dns := range d.vpnDNS {
		content += fmt.Sprintf("nameserver %s\n", dns)
	}

	// Add options for security
	content += "\noptions edns0 trust-ad\n"

	return os.WriteFile("/etc/resolv.conf", []byte(content), 0644)
}

// blockNonVPNDNS blocks DNS queries not going through VPN
func (d *DNSManager) blockNonVPNDNS() error {
	// Block outgoing DNS on all interfaces except VPN
	rules := [][]string{
		// Block DNS over UDP
		{"-t", "filter", "-A", "OUTPUT", "-p", "udp", "--dport", "53", "!", "-o", "wg+", "-j", "DROP"},
		{"-t", "filter", "-A", "OUTPUT", "-p", "udp", "--dport", "53", "!", "-o", "tun+", "-j", "DROP"},

		// Block DNS over TCP
		{"-t", "filter", "-A", "OUTPUT", "-p", "tcp", "--dport", "53", "!", "-o", "wg+", "-j", "DROP"},
		{"-t", "filter", "-A", "OUTPUT", "-p", "tcp", "--dport", "53", "!", "-o", "tun+", "-j", "DROP"},

		// Block DNS over TLS (port 853)
		{"-t", "filter", "-A", "OUTPUT", "-p", "tcp", "--dport", "853", "!", "-o", "wg+", "-j", "DROP"},
		{"-t", "filter", "-A", "OUTPUT", "-p", "tcp", "--dport", "853", "!", "-o", "tun+", "-j", "DROP"},
	}

	for _, rule := range rules {
		cmd := exec.Command("iptables", rule...)
		if err := cmd.Run(); err != nil {
			log.Printf("Warning: failed to add DNS blocking rule: %v", err)
		}
	}

	return nil
}

// unblockDNS removes DNS blocking rules
func (d *DNSManager) unblockDNS() error {
	// Remove DNS blocking rules
	rules := [][]string{
		{"-t", "filter", "-D", "OUTPUT", "-p", "udp", "--dport", "53", "!", "-o", "wg+", "-j", "DROP"},
		{"-t", "filter", "-D", "OUTPUT", "-p", "udp", "--dport", "53", "!", "-o", "tun+", "-j", "DROP"},
		{"-t", "filter", "-D", "OUTPUT", "-p", "tcp", "--dport", "53", "!", "-o", "wg+", "-j", "DROP"},
		{"-t", "filter", "-D", "OUTPUT", "-p", "tcp", "--dport", "53", "!", "-o", "tun+", "-j", "DROP"},
		{"-t", "filter", "-D", "OUTPUT", "-p", "tcp", "--dport", "853", "!", "-o", "wg+", "-j", "DROP"},
		{"-t", "filter", "-D", "OUTPUT", "-p", "tcp", "--dport", "853", "!", "-o", "tun+", "-j", "DROP"},
	}

	for _, rule := range rules {
		cmd := exec.Command("iptables", rule...)
		cmd.Run() // Ignore errors - rule might not exist
	}

	return nil
}

// CheckDNSLeak tests for DNS leaks
func (d *DNSManager) CheckDNSLeak() (bool, error) {
	// Query a DNS server to check if it's using VPN DNS
	cmd := exec.Command("dig", "+short", "myip.opendns.com", "@resolver1.opendns.com")
	output, err := cmd.Output()
	if err != nil {
		return false, fmt.Errorf("failed to check DNS: %w", err)
	}

	// Check if the response indicates VPN DNS is being used
	// This is a simplified check - in production, compare against known VPN DNS servers
	log.Printf("DNS check result: %s", string(output))

	return true, nil
}
